# 程序结构 

## 命名
一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线

Go语言程序员推荐使用 `驼峰式` 命名。

## 声明  
> boiling 主要说明包一级的范围声明。ftoc简单的说明方法如何调用
Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明

## 变量
>主要展示各种各样的变量声明（包含变量的一般形式，简短形式，指针，new函数）以及`变量的生命周期`

### 变量申明常见形式：
```go
//类型 或者表达式可省略
var 变量名字 类型 = 表达式
```
变量的零值：
数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

### 简短变量声明：`:=` 无需

这个主要被用于大部分的局部变量的申明和初始化。

注意此种声明左边至少声明一个新变量，否则代码将不会通过。
```go
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables

//这样改才能通过
out, err := os.Create(outfile) //out是一个新变量
```
### 指针 

指针类型的声明和初始化和c一样
```go
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```

指针之间的比较操作：只有指针指向同一个变量或者全部是nil才为true

echo4介绍了flag包用法，其中关键是使用了指针类型接收特殊参数。

### new函数
表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。其实就是为了不想申明一个指针对象而指定一个声明变量。

new 不是一个关键字，它可以作为变量名如下.
```go
//这里的new是一个变量名，注意到省略了old类型
//在此函数内无法使用new函数来声明变量。
func delta(old, new int) int { return new - old }
```

### 变量的生命周期
- 对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的.
- 局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。
- 从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的.
- 编译器会自动选择在栈上还是在堆上分配局部变量的存储空间,这取决于程序的行为，比如将一个局部变量的地址给一个包指针变量，此变量的内存分配将会在堆上分配。

## 赋值

* 自增和自减是语句，而不是表达式，因此x = i++之类的表达式是错误的。

* 元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。

* 一些特别奇怪的赋值操作：
```go
v, ok = m[key]             // map 搜索
v, ok = x.(T)              // type 断言
v, ok = <-ch               // channel 接收
//这就十分有趣了，这么搞。我哪知道接收几个值？
v = m[key]                // map查找，失败时返回零值
v = x.(T)                 // type断言，失败时panic异常
v = <-ch                  // 管道接收，失败时返回零值（阻塞不算是失败）
```
### 类型 

> tempconv0 主要讲述type关键字的使用，以及如何声明一个特定类型的方法。

*type 类型名字 底层类型
```go
type Celsius float64    // 摄氏温度
type Fahrenheit float64 // 华氏温度
```
* 类型转换和方法调用的形式基本一模一样，需要看看那个前面的名到底是个方法名还是一个类型名。

* 类型名不同，基本的操作也是不同的

* 类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。

## 包的特性

### 包的使用
> tempconv 主要演示包的用法，主要包含如何访问同一个包下的变量，cf主要展示如何跨包访问。

### 包的初始化顺序
> PopCount函数用于展示是如何初始化的，主要说明init函数的用法
```go
//todo： 为什么可以说将初始化逻辑包装为一个匿名函数处理？
// pc[i] is the population count of i.
var pc [256]byte = func() (pc [256]byte) {
    for i := range pc {
        pc[i] = pc[i/2] + byte(i&1)
    }
    return
}()

```
* 首先初始化为包级别的变量初始化，注意有两种初始化方式，一个是按照表达式的顺序进行初始化，另一个是根据inti函数进行初始化，每个文件可以包含多个init函数，执行顺序按照声明顺序自动调用。

## 作用域

* 句法块是由花括弧所包含的一系列语句，句法块内部声明的名字是无法被外部块访问的。这个块决定了内部声明的名字的作用域范围。

* if,for ,switch 会创建两个作用域，其中 if-else-if 中间会有一些作用域规则

* 包级别的声明顺序不会影响作用域范围，方法可以相互嵌套但是变量或常量不能递归引用自身。

* 包级别的变量赋值不要和简短声明一起使用，这会造成语义的修改