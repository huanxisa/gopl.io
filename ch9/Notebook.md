# 基于共享变量的并发

## 竞争条件

* 避免写
* 避免共享变量
* 不要使用共享数据来通信；使用通信来共享数据：见bank1
* 使用互斥

## 互斥锁

> bank2使用了管道的方式实现了类似于锁的效果，bank2直接使用了锁

* go里没有重入锁，这在某些情况下造成问题，见互斥锁这章，解决办法为拆解函数为更小的块。

## 读写锁
允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作“多读单写”锁。

## 内存同步
由于现代计算机的优化，会有指令重排的现象出现，在导致如果在逻辑上理应出现的状况而没有出现，例如，有两个共享变量，两个线程更新其中变量，打印另一个变量，但是执行出来确实两个都没有更新的状况。

## 并发初始化
```go
var loadIconsOnce sync.Once
var icons map[string]image.Image
// Concurrency-safe.
func Icon(name string) image.Image {
	//关键
    loadIconsOnce.Do(loadIcons)
    return icons[name]
}
```
## 竞争条件检测
go build，go run或者go test命令后面加上-race的flag

## 并发的非阻塞缓存

> 见memo系列代码，其中memo4和memo5是成熟版本，memo4使用的是锁，memo5使用的是channel，这两个设计都十分巧妙。需要细品

## Goroutines和线程
一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。

* 从一个线程向另一个“移动”需要完整的上下文切换，这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的cpu周期。
* Go的运行时包含了其自己的调度器。Go调度器并不是用一个硬件定时器，而是被Go语言“建筑”本身进行调度的。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。

### go的调度原理
Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的代码。其默认的值是运行机器上的CPU的核心数，所以在一个有8个核心的机器上时，调度器一次会在8个OS线程上去调度GO代码。

可以用GOMAXPROCS的环境变量来显式地控制这个参数，或者也可以在运行时用runtime.GOMAXPROCS函数来修改它。

